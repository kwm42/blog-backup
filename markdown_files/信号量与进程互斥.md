---
title: 信号量与进程互斥
date: 2018-05-27 17:12:53
tags:
---

# 信号量与进程互斥

信号量与进程互斥

<!-- more -->

## 资源互斥

 当多个进程或线程使用同一个资源或者共享对象时可能产生冲突，从而导致他们所使用的资源状态发生异常，导致意料之外的结果。

 举个简单的例子：**小明** 拥有100金币，现在有两个线程 p1 和 p2 ，他们的功能是修改小明的金币数量，他们的执行过程如下:

```
void updateCoin(n){
    //获得当前金币数量
	int oldCoin=getCoinNumber();
	//增加金币数量
	int newCoin=oldCoin+n;
    //更新小明的金币
    setCoin(newCoin);
}
```

 两个线程执行 updateCoin(10) 和 updateCoin(20) 的执行情况如下：

| p1 : updateCoin(10)          | p2 : updateCoin(20)          |
| ---------------------------- | ---------------------------- |
| int oldCoin=getCoinNumber(); |                              |
|                              | int oldCoin=getCoinNumber(); |
| int newCoin=oldCoin+n;       |                              |
|                              | int newCoin=oldCoin+n;       |
|                              | setCoin(newCoin);            |
| setCoin(newCoin);            |                              |

 结果本应该是 130 ，但是上面的代码结果是 110 ，为什么尼？上面执行过程的前两步完成之后 p1 和 p2 得到的金币数量都是 100 ，这时 p1 增加 10 个金币，p2 增加 20 个金币，此时他们认为新的金币数量分别是 110 和 120，然后第五步 p2 修改小明的金币为 120，但是 p1 接下来会修改金币为 110，这就导致了错误。解决办法是修改执行顺序，例如 p1 顺序执行结束后小明的金币为110，这时在开始执行 p2 ，这样 p2 读出的金币数量就是110，接着增加 20，就没有问题了。但是线程的执行过程无法判断，所以使用信号量来解决资源互斥的问题。

## 什么是信号量

 《操作系统原理》这本书上是这么说的：

> 信号量（semaphore）有时被称为信号灯，是解决并发问题过程中所使用的一种设施，可以用来保证两个或多个关键代码不被并发使用。在进入一个关键代码之前，进程（或线程）必须获取一个信号量；一旦该关键代码完成了，那么该进程（线程）必须释放信号量。其他想进入关键代码的进程（线程）必须等待直到第一个进程（线程）释放信号量。
>
>  –周苏 金海龙.2013.《操作系统原理》.机械工业出版社.p106

 信号量最重要的是有两个操作 semWait() 和 semSignal()，semWait()使得信号量的数值 -1 ，表示有一个进程（或线程）想要使用共享资源或进入临界区，semSignal()使得信号量的数值 +1 ，表示其中一个进程（线程）执行完毕离开临界区或释放资源，开始时，可以初始化信号量为0或正数，表示允许进入该临界区或使用共享资源的进程（线程）数量。



 我在网上看到一个恰当的比喻，大概意思就是：想象这里有一个房子（即临界区或共享资源），房子里面有很多玩具，有一堆小盆友（进程或线程）想要进入房子里面玩玩具（进入临界区或使用共享资源），但是房子不够大只能容纳一部分小盆友，所以房子的管理员想了一个办法，即在门口放一个箱子，箱子里面有门票（信号量），拿到门票的小盆友可以进入房子（门票的数量就是信号量的大小），没有门票就在门口等里面的小盆友出来，小盆友出来时把门票放回箱子里面（使用完了之后释放资源），其他小盆友就可以拿门票进去了，这样就可以控制进入临界区的进程数量。

## 使用信号量

 还是上面的金币问题，我们现在使用信号量来解决这个问题。

 定义信号量如下：

```
struct semaphore{
    int count;
    queueType queue;
}
void semWait(semaphore s){
    //有一个进程（线程）想要使用资源
    s.count--;
    if(s.count<0){
        //把当前进程插入等待队列
        //阻塞当前进程
    }
}
void semSignal(semaphore s){
    //某个进程（线程）释放资源
    s.count++;
    if(s.count<=0){
        //将队列中的一个进程变成就绪态
    }
}
```

 我们现在考虑有n个线程（p1 , p2 … pn）想要修改小明的金币，同一时间只允许一个线程工作，可以得到程序代码如下：

```
//线程数
int n;
//信号量，允许一个线程
semaphore s=1;

void p(){
    while(true){
        semWait(s);
   	 	//临界区，修改小明的金币
    	updateCoin(n);
    	semSignal(s);
    	//剩下部分
    }
}

void main(){
    compete(p1(),p2(),p3()....pn());
}
```

 这样在同一时间只有一个线程可以修改金币，其他线程必须等待当前线程完成工作退出临界区。



- s.count >= 0 : 此时表示可以执行不必被阻塞的进程数
- s.count < 0 : 此时表示队列中被阻塞的进程数